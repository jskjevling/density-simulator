package {	import flash.display.Sprite;	import flash.utils.*;	import flash.events.*;	import Ball;	import LineText;	import DensityEq;	import ScreenCube;	import HeightMm;	import FontList;	import ValueSlider;		[SWF(width=500, height=500, backgroundColor=0xDDDDDD)]		public class DensityExp extends Sprite {  		// constants weight of water: 1g/cm3		//           weight of air: 0.00121g/cm3		//           mass of air: 0.00012334353g/cm3		//           Earth's gravity: 9.81 m/s squared		//           weight = mass*gravity so w/g = m		//           buoyant mass: m(b) = m(object) x (1- (p(fluid)/ p(object)))		//           buoyant force: F(buoyant) = -pVg		//           Relative Density = Weight / (Weight - Apparent Immersed Weight)		//           Volume of a sphere: V = 4pi*r^3/3		//           Volume of a cube: a*b*c		private var t:*;		private var theBall:Ball;		private var densityEq:DensityEq;		private var screenCube:ScreenCube;		private var heightMm:HeightMm;		private var cubeW:Number = 450;		private var cubeH:Number = 400;		private var cubeD:Number = 200;		private var ballRadius:Number = 50;		private var ballDensity:Number = 1;		private var ballVolume:Number;		private var ballWeight:Number;		private var ballX:Number;		private var ballY:Number;		private var minY:Number;		private var maxY:Number;		private var accelTimer:Timer;		private var accelForce:Number;		private var prevAccelForce:Number;		private var gravForce:Number = 0;		private var gravAccelForce:Number = 0;		private var firstRun:Boolean = true;		private var totalForce:Number;		private var n:* = FontList.ARIAL_FONT;		private var gravityVal:Number = 9.81;		private var subDensity:Number = .00121		private var displacedWeight:Number;		private var appliedForce:Number;		private var gravitySlider:ValueSlider;		private var gravityText:LineText;		private var bDensitySlider:ValueSlider;		private var bDensityText:LineText;		private var sDensitySlider:ValueSlider;		private var sDensityText:LineText;		private var bRadiusSlider:ValueSlider;		private var bRadiusText:LineText;		private var statusText:LineText;				public function DensityExp() {			init();		}				public function init():void {			t = this;			makeCube();			minY = screenCube.y+50+ballRadius;			maxY = cubeH-(25+ballRadius);			ballX = stage.stageWidth/2;			ballY = (cubeH/2)+screenCube.y;			makeSlider1();			makeSlider2();			makeSlider3();			makeSlider4();			//makeDensityEq();			makeHeightMm(("H "+cubeH), 100, 243, -90);			makeHeightMm(("D "+cubeD), 55, 351, -45);			makeHeightMm(("W "+cubeW), 231, 300, 0);			makeBall(ballRadius, ballDensity);			this.addEventListener(Event.ENTER_FRAME, setConditions);			t.gravityText = new LineText("g = ", 0x333333, 0, 0, 0);			position(t.gravityText, 135, 435);			addChild(t.gravityText);			t.bDensityText = new LineText("ball ρ = ", 0x333333, 0, 0, 0);			position(t.bDensityText, 135, 455);			addChild(t.bDensityText);			t.sDensityText = new LineText("fluid ρ = ", 0x333333, 0, 0, 0);			position(t.sDensityText, 360, 435);			addChild(t.sDensityText);			t.bRadiusText = new LineText("ball r = ", 0x333333, 0, 0, 0);			position(t.bRadiusText, 360, 455);			addChild(t.bRadiusText);			calculateForce();			t.statusText = new LineText(("ball weight = "+ballWeight+" N - displaced weight = "+displacedWeight+" N - applied force = "+appliedForce+" N"), 0x333333, 0, 0, 0);			position(t.statusText, 25, 475);			addChild(t.statusText);		}				private function accelFunction():void {			if (ballY==minY||ballY==maxY) {				gravForce = 0;				gravAccelForce = 0;				firstRun = true;				trace("gravForce stationary == "+gravForce);			} else if (gravForce==0&&firstRun==true) {				firstRun = false;				trace("gravForce first run == "+gravForce);				return;			} else {				if (appliedForce==0) {					gravAccelForce = gravForce + (-prevAccelForce);					if (gravForce<0.5&&gravForce>-0.5) {						prevAccelForce=0;						gravForce = 0;						accelForce = 0;					}					gravForce = gravAccelForce;					trace("gravForce stop accel == "+gravForce+" and gravAccelForce == "+gravAccelForce);				} else {					gravForce = gravForce+accelForce;					gravAccelForce = gravForce;					prevAccelForce = accelForce;					trace("gravForce accellerating == "+gravForce+" and gravAccelForce == "+gravAccelForce+" and prevAccelForce == "+prevAccelForce);				}			}		}				private function makeCube():void {			screenCube = new ScreenCube(cubeW, cubeH, cubeD, 0x777777);			position(screenCube, 25, 25);			addChild(screenCube);		}				private function makeSlider1():void {			gravitySlider = new ValueSlider(98);			position(gravitySlider, 25, 445);			addChild(gravitySlider);		}				private function makeSlider2():void {			bDensitySlider = new ValueSlider(100);			position(bDensitySlider, 25, 465);			addChild(bDensitySlider);		}				private function makeSlider3():void {			sDensitySlider = new ValueSlider(1);			position(sDensitySlider, 250, 445);			addChild(sDensitySlider);		}				private function makeSlider4():void {			bRadiusSlider = new ValueSlider(ballRadius);			position(bRadiusSlider, 250, 465);			addChild(bRadiusSlider);		}				private function makeDensityEq():void {			densityEq = new DensityEq(110,110);			addChild(densityEq);		}				private function makeHeightMm(val:String, txtX:Number, txtY:Number, txtRotation:Number):void {			heightMm = new HeightMm(val, txtX, txtY, txtRotation);			addChild(heightMm);		}				private function makeBall(radius:Number, ballAlpha:Number):void {			if (theBall!=null) {				removeChild(theBall);				theBall = null;			}			theBall = new Ball(radius, 0xff0000, ballAlpha);			position(theBall, ballX, ballY);			addChild(theBall);			ballVolume = theBall.realVolume;			trace(theBall.y+" is theBall's y value");		}				private function setConditions(e:Event):void {			displayGravity();			displayBallDensity();			displaySubDensity();			displayBallRadius();			calculateForce();			trace("calculated the Force");			displayStatusText();			trace("displayed the status text");			accelFunction();			trace("ran accel function");			accelBall();			trace("accelerated ball");			makeBall(ballRadius, (ballDensity*10));			trace("made ball");		}				private function displayGravity():void {			t.gravityVal = t.gravitySlider.sliderValue/10;			t.kill(gravityText);			t.gravityText = new LineText(("g = "+t.gravityVal+" N"), 0x333333, 135, 445, 0);			position(t.gravityText, 135, 435);			t.addChild(gravityText);		}				private function displayBallDensity():void {			t.ballDensity = t.bDensitySlider.sliderValue/1000;			t.kill(bDensityText);			t.bDensityText = new LineText("ball ρ = "+t.ballDensity+" g/cm3", 0x333333, 0, 0, 0);			position(t.bDensityText, 135, 455);			t.addChild(bDensityText);		}				private function displaySubDensity():void {			t.subDensity = t.sDensitySlider.sliderValue/1000;			t.kill(sDensityText);			t.sDensityText = new LineText("fluid ρ = "+t.subDensity+" g/cm3", 0x333333, 0, 0, 0);			position(t.sDensityText, 360, 435);			addChild(t.sDensityText);		}				private function displayBallRadius():void {			t.ballRadius = t.bRadiusSlider.sliderValue;			t.kill(bRadiusText);			t.bRadiusText = new LineText("ball r = "+t.ballRadius+" cm", 0x333333, 0, 0, 0);			position(t.bRadiusText, 360, 455);			addChild(t.bRadiusText);		}				private function calculateForce():void {			ballWeight = Math.round(((t.theBall.realVolume * t.ballDensity / 1000) * t.gravityVal)*1000)/1000;			displacedWeight = Math.round(((t.theBall.realVolume * t.subDensity / 1000) * t.gravityVal)*1000)/1000;			appliedForce = Math.round((ballWeight-displacedWeight)*1000)/1000;		}				private function displayStatusText():void {			t.kill(statusText);			t.statusText = new LineText(("ball weight = "+ballWeight+" N | displaced weight = "+displacedWeight+" N | applied force = "+appliedForce+" N"), 0x333333, 0, 0, 0);			position(t.statusText, 25, 475);			addChild(t.statusText);		}				private function kill(which:*):void {			removeChild(which);			which = null;		}				private function position(which:*, theX:Number, theY:Number):void {			which.x = theX;			which.y = theY;		}				private function accelBall():void {			accelForce = (appliedForce*100)/stage.frameRate;			calcAccel();						if (ballY<minY) {				ballY=minY;			} else if (ballY>maxY) {				ballY=maxY;			}			if ((ballY+=totalForce)<minY) {				ballY = minY;			} else if ((ballY+=totalForce)>maxY) {				ballY = maxY;			} else {				if (appliedForce==0) {					trace("applied force is 0");					ballY = ballY;					trace("this is the ball's Y value: "+ballY);					return;				} else {					ballY+=totalForce;					trace("added "+totalForce+" to ballY");					trace("total force = "+totalForce);				}			}		}				private function calcAccel():void {			totalForce = Math.round((gravAccelForce+accelForce)*100)/100;		}	}}